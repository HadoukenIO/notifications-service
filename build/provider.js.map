{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./staging/src/provider/Persistence/DataLayer/IndexedDb.js","webpack:///./staging/src/provider/Persistence/DataLayer/Repositories/HistoryRepository.js","webpack:///./staging/src/provider/Persistence/DataLayer/Repositories/Repository.js","webpack:///./staging/src/provider/Persistence/DataLayer/Repositories/RepositoryEnum.js","webpack:///./staging/src/provider/Persistence/DataLayer/Repositories/RepositoryFactory.js","webpack:///./staging/src/provider/Persistence/DataLayer/Repositories/SettingsRepository.js","webpack:///./staging/src/provider/Persistence/Models/Sort.js","webpack:///./staging/src/provider/index.js","webpack:///./staging/src/shared/Models/NotificationTypes.js","webpack:///./staging/src/shared/config.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;ACnEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gBAAgB;AACxF;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qCAAqC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gDAAgD;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,qC;;;;;;;;;;;;AC7TA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;ACnHA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA,oBAAoB,6EAA6E,eAAe;AAChH;AACA,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAuD,GAAG;AAC9E;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAA4C,GAAG;AACnE;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAA+D,UAAU;AAC7F;AACA;AACA;AACA,oBAAoB;AACpB;AACA,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,gBAAgB;AAChB;AACA;AACA;AACA,sC;;;;;;;;;;;;ACtIA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mEAAmE;AACpE,0C;;;;;;;;;;;;ACXA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;AC7CA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;AC7EA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C,gC;;;;;;;;;;;;ACVA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS,aAAa,gBAAgB;AACzF;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa,GAAG,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB,iBAAiB;AAC7E;AACA,+CAA+C,gBAAgB,gBAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,YAAY;AACvB;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;AChWA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kFAAkF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;ACzBA;AACA,8CAA8C,cAAc;AAC5D;AACA,kC","file":"provider.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./staging/src/provider/index.js\");\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Sort_1 = require(\"../Models/Sort\");\r\n/**\r\n * @description An IndexedDb implementation implementing the IDatastore\r\n * interface\r\n */\r\nclass IndexedDb {\r\n    /**\r\n     * @constructor Constructor for IndexedDb\r\n     */\r\n    constructor(db) {\r\n        this.mIndexedDb = db;\r\n    }\r\n    /**\r\n     * @method initialise Initialises the database and does all setup\r\n     * @param {number} dbVersion The version of the database\r\n     * @param {ITable[]} tablesToCreate These are needed in order to recreate the table names should the version be upgraded\r\n     * @public\r\n     */\r\n    initialise(dbVersion, tablesToCreate) {\r\n        if (!dbVersion) {\r\n            console.error('No database name has been passed in');\r\n            return;\r\n        }\r\n        this.mDbOpenRequest = this.mIndexedDb.open('Notifications', dbVersion);\r\n        this.mDbOpenRequest.onupgradeneeded = (event) => {\r\n            const db = event.target.result;\r\n            try {\r\n                tablesToCreate.forEach(table => {\r\n                    if (!db.objectStoreNames.contains(table.name)) {\r\n                        const store = db.createObjectStore(table.name, { keyPath: 'id' });\r\n                        if (table.indexName && table.index) {\r\n                            const index = store.createIndex(table.indexName, [table.index]);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            catch (err) {\r\n                console.error('error: ', err);\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * @method create Add an entry into the database based on the table name\r\n     * @param {string} tableName The name of the table to perform\r\n     * @param {T} entry Object to insert into the database\r\n     * @public\r\n     * @returns {Promise<boolean>} A value of whether it was successfully created or not\r\n     */\r\n    create(tableName, entry) {\r\n        if (!tableName) {\r\n            console.error('No table name has been passed');\r\n            return Promise.reject('No table name has been passed');\r\n        }\r\n        if (!entry) {\r\n            console.error('No entry has been passed');\r\n            return Promise.reject('No entry has been passed');\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const db = this.mDbOpenRequest.result;\r\n            const transaction = db.transaction(tableName, 'readwrite');\r\n            const store = transaction.objectStore(tableName);\r\n            const request = store.add(entry);\r\n            request.onsuccess = (event) => {\r\n                console.log('The entry has been inserted');\r\n                resolve(true);\r\n            };\r\n            request.onerror = (event) => {\r\n                console.error('The entry could not be inserted: ', event);\r\n                resolve(false);\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * @method remove Deletes an entry in the database based on the table name\r\n     * @param {string} tableName The name of the table to perform\r\n     * @param {T} id The id of the entry we want to remove\r\n     * @public\r\n     * @returns {Promise<boolean>} A value of whether it was successfully created or not\r\n     */\r\n    remove(tableName, id) {\r\n        if (!tableName) {\r\n            console.error('No table name has been passed');\r\n            return Promise.reject('No table name has been passed');\r\n        }\r\n        if (!id) {\r\n            console.error('No id has been passed');\r\n            return Promise.reject('No id has been passed');\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const db = this.mDbOpenRequest.result;\r\n            const transaction = db.transaction(tableName, 'readwrite');\r\n            const store = transaction.objectStore(tableName);\r\n            const request = store.delete(id);\r\n            request.onsuccess = (event) => {\r\n                console.log('The entry has been deleted');\r\n                resolve(true);\r\n            };\r\n            request.onerror = (event) => {\r\n                console.error('The entry could not be deleted: ', event);\r\n                resolve(false);\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * @method removeAll Deletes all entries in the database based on the table\r\n     * name\r\n     * @param {string} tableName The name of the table to perform\r\n     * @public\r\n     * @returns {Promise<boolean>} A value of whether it was successfully created or not\r\n     */\r\n    removeAll(tableName) {\r\n        if (!tableName) {\r\n            console.error('No table name has been passed');\r\n            return Promise.reject('No table name has been passed');\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const db = this.mDbOpenRequest.result;\r\n            const transaction = db.transaction(tableName, 'readwrite');\r\n            const store = transaction.objectStore(tableName);\r\n            const request = store.clear();\r\n            request.onsuccess = (event) => {\r\n                console.log('The entry has been deleted');\r\n                resolve(true);\r\n            };\r\n            request.onerror = (event) => {\r\n                console.error('The entry could not be deleted: ', event);\r\n                resolve(false);\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * @method removeByUuid Deletes all entries corresponding to the uuid passed\r\n     * in\r\n     * @param {string} tableName The name of the table to perform\r\n     * @param {string} uuid The uuid of the app\r\n     * @public\r\n     * @returns {Promise<boolean>} A value of whether it was successfully created or not\r\n     */\r\n    removeByUuid(tableName, uuid) {\r\n        return new Promise((resolve, reject) => {\r\n            this.readByUuid(tableName, uuid)\r\n                .then((result) => {\r\n                result.forEach((notification) => {\r\n                    this.remove(tableName, notification.id);\r\n                });\r\n                resolve(true);\r\n            })\r\n                .catch((err) => {\r\n                resolve(false);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * @method update Update an entry into the database based on the table name\r\n     * @param {string} tableName The name of the table to perform\r\n     * @param {T} entry Object to update in the database\r\n     * @public\r\n     * @returns {Promise<boolean>} A value of whether it was successfully created or not\r\n     */\r\n    update(tableName, entry) {\r\n        if (!tableName) {\r\n            console.error('No table name has been passed');\r\n            return Promise.reject('No table name has been passed');\r\n        }\r\n        if (!entry) {\r\n            console.error('No entry has been passed');\r\n            return Promise.reject('No entry has been passed');\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const db = this.mDbOpenRequest.result;\r\n            const transaction = db.transaction(tableName, 'readwrite');\r\n            const store = transaction.objectStore(tableName);\r\n            const request = store.put(entry);\r\n            request.onsuccess = (event) => {\r\n                console.log('The entry has been updated');\r\n                resolve(true);\r\n            };\r\n            request.onerror = (event) => {\r\n                console.error('The entry could not be updated: ', event);\r\n                resolve(false);\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * @method read Reads an entry in the database based on the table name\r\n     * @param {string} tableName The name of the table to perform\r\n     * @param {string} id The id of the entry we want to remove\r\n     * @public\r\n     * @returns {Promise<T>} Returns a promise to retrieve the data requested\r\n     */\r\n    read(tableName, id) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!tableName) {\r\n                reject('No table name has been passed');\r\n            }\r\n            if (!id) {\r\n                reject('No id has been passed in');\r\n            }\r\n            const db = this.mDbOpenRequest.result;\r\n            const transaction = db.transaction(tableName, 'readwrite');\r\n            const store = transaction.objectStore(tableName);\r\n            const request = store.get(id);\r\n            request.onsuccess = (event) => {\r\n                resolve(request.result);\r\n                console.log('Read has been executed');\r\n            };\r\n            request.onerror = (event) => {\r\n                console.error('The entry could not be updated: ', event);\r\n                resolve(null);\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * @method readAll Reads all rows from the table specified\r\n     * @param {string} tableName The table to be read form\r\n     * @public\r\n     * @returns {Promise<T>} Returns a promise to retrieve the data requested\r\n     */\r\n    readAll(tableName) {\r\n        return new Promise((resolve, reject) => {\r\n            const result = [];\r\n            const db = this.mDbOpenRequest.result;\r\n            const transaction = db.transaction(tableName, 'readonly');\r\n            const store = transaction.objectStore(tableName);\r\n            const cursorRequest = store.openCursor(null, 'next');\r\n            cursorRequest.onsuccess = (event) => {\r\n                const cursor = event.target.result;\r\n                if (cursor) {\r\n                    result.push(cursor.value);\r\n                    cursor.continue();\r\n                }\r\n                else {\r\n                    resolve(result);\r\n                }\r\n            };\r\n            cursorRequest.onerror = (event) => {\r\n                console.error('Could not read from table ' + tableName, event);\r\n                resolve(null);\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * @method readByUuid Gets all entries from the database corresponding to the\r\n     * Uuid\r\n     * @param tableName The name of the table to perform actions on\r\n     * @param uuid The uuid to query by\r\n     * @public\r\n     * @returns {Promise<T[]>} Returns a promise to retrieve the data requested\r\n     */\r\n    readByUuid(tableName, uuid) {\r\n        return new Promise((resolve, reject) => {\r\n            const result = [];\r\n            const db = this.mDbOpenRequest.result;\r\n            const transaction = db.transaction(tableName, 'readonly');\r\n            const store = transaction.objectStore(tableName);\r\n            const cursorRequest = store.openCursor(null, 'next');\r\n            cursorRequest.onsuccess = (event) => {\r\n                const cursor = event.target.result;\r\n                if (cursor) {\r\n                    if (cursor.value.uuid === uuid) {\r\n                        result.push(cursor.value);\r\n                    }\r\n                    cursor.continue();\r\n                }\r\n                else {\r\n                    resolve(result);\r\n                }\r\n            };\r\n            cursorRequest.onerror = (event) => {\r\n                console.error('Could not read from table ' + tableName, event);\r\n                resolve(null);\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * @method readByPage Gets the result on the page specified\r\n     * @param tableName The table to be read from\r\n     * @param pageInfo The requested page and the number of items to be returned\r\n     * from the apge\r\n     * @public\r\n     * @returns {Promise<T[]>} Returns a promise to retrieve the data requested\r\n     */\r\n    readByPage(tableName, pageInfo) {\r\n        return new Promise((resolve, reject) => {\r\n            const result = [];\r\n            this.readAll(tableName).then((notifications) => {\r\n                if (notifications.length === 0) {\r\n                    console.error('There are no entries in the database');\r\n                    resolve(null);\r\n                }\r\n                else {\r\n                    const offset = (pageInfo.pageNumber - 1) * pageInfo.numberOfItems;\r\n                    // Depending on which sorting is applied we will\r\n                    if (pageInfo.sort === Sort_1.Sorts.ascending) {\r\n                        for (let i = offset; i < offset + pageInfo.numberOfItems; i++) {\r\n                            if (notifications[i] != null) {\r\n                                result.push(notifications[i]);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        const reverseLoopOffset = (notifications.length - offset) - 1;\r\n                        for (let i = reverseLoopOffset; i > reverseLoopOffset - pageInfo.numberOfItems; i--) {\r\n                            if (notifications[i] != null) {\r\n                                result.push(notifications[i]);\r\n                            }\r\n                        }\r\n                    }\r\n                    resolve(result);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\nexports.IndexedDb = IndexedDb;\r\n//# sourceMappingURL=IndexedDb.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Repository_1 = require(\"./Repository\");\r\n/**\r\n * @class Repository for history of notification\r\n */\r\nclass HistoryRepository extends Repository_1.Repository {\r\n    /**\r\n     * @constructor Constructor\r\n     * @param {IDatastore} datastore The low level database layer\r\n     */\r\n    constructor(datastore) {\r\n        super(datastore, 'history');\r\n    }\r\n    /**\r\n     * @method getTableName return the table name\r\n     * @returns {string} The name of the table\r\n     * @public\r\n     */\r\n    get getTableName() {\r\n        return super.getTableName;\r\n    }\r\n    /**\r\n     * @method create Creates a notification in the database\r\n     * @param {INotificationEvent} notification The notification to be saved\r\n     * @public\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async create(notification) {\r\n        return await super.genericCreate(notification);\r\n    }\r\n    /**\r\n     * @method getAll Gets all notifications in the database\r\n     * @public\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async getAll() {\r\n        return await super.genericGetAll();\r\n    }\r\n    /**\r\n     * @method getById Retrieves the notification corresponding to that Id\r\n     * @param id The id of the notification\r\n     * @public\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async getById(id) {\r\n        return await super.genericGetById(id);\r\n    }\r\n    /**\r\n     * @method getByUuid Retrieves all notifications given a uuid\r\n     * @param uuid THe uuid of the app\r\n     * @public\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async getByUuid(uuid) {\r\n        const result = await this.mDataStore.readByUuid(this.TABLENAME, uuid);\r\n        if (result == null) {\r\n            return { success: false, errorMsg: 'Could not retrieve by uuid: ' + uuid, value: null };\r\n        }\r\n        return { success: true, value: result };\r\n    }\r\n    /**\r\n     * @method remove Remove a notification from the history store\r\n     * @param {string} id The id of the notification\r\n     * @public\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async remove(id) {\r\n        return await super.genericRemove(id);\r\n    }\r\n    /**\r\n     * @method removeAll Removes all notifications fomr the history store\r\n     * @public\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async removeAll() {\r\n        return await super.genericRemoveAll();\r\n    }\r\n    /**\r\n     * @method removeByUuid Removes all notification related to a specific\r\n     * application\r\n     * @param {string} uuid The uuid of the application\r\n     * @public\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async removeByUuid(uuid) {\r\n        if (!uuid) {\r\n            throw new Error('No uuid was supplied');\r\n        }\r\n        const result = await this.mDataStore.removeByUuid(this.TABLENAME, uuid);\r\n        if (!result) {\r\n            return { success: result, errorMsg: 'Could not remove all entries in the database with the given uuid: ' + uuid };\r\n        }\r\n        return { success: result };\r\n    }\r\n    /**\r\n     * @method update Updates a notification in the history store\r\n     * @param updatedNotification The updated notification\r\n     * @public\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async update(updatedNotification) {\r\n        return await super.genericUpdate(updatedNotification);\r\n    }\r\n    /**\r\n     * @method getByPage Gets the results depending on the page\r\n     * @param {PageInfo} pageInfo Metadata around the number of items on a page and the page number\r\n     * @public\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async getByPage(pageInfo) {\r\n        return await super.genericGetByPage(pageInfo);\r\n    }\r\n}\r\nexports.HistoryRepository = HistoryRepository;\r\n//# sourceMappingURL=HistoryRepository.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @class Base repository for all child repositories\r\n */\r\nclass Repository {\r\n    /**\r\n     * @constructor Constructor\r\n     * @param {IDatastore} datastore The low level database layer\r\n     * @param {string} tableName The name of the table the repository will be responsible for\r\n     */\r\n    constructor(datastore, tableName) {\r\n        this.mDataStore = datastore;\r\n        this.TABLENAME = tableName;\r\n    }\r\n    /**\r\n     * @method getTableName return the table name\r\n     * @returns {string} The name of the table\r\n     * @public\r\n     */\r\n    get getTableName() {\r\n        return this.TABLENAME;\r\n    }\r\n    /**\r\n     * @method genericCreate Creates a entity in the database\r\n     * @param {T} entity The entity to be saved into the database\r\n     * @protected\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async genericCreate(entity) {\r\n        if (!entity) {\r\n            throw new Error('No entity was passed');\r\n        }\r\n        const result = await this.mDataStore.create(this.TABLENAME, entity);\r\n        if (!result) {\r\n            return { success: result, errorMsg: 'Could not insert into database: ' + JSON.stringify(entity), value: null };\r\n        }\r\n        return { success: result, value: entity };\r\n    }\r\n    /**\r\n     * @method genericGetAll Gets all entities in the database from the table\r\n     * @protected\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async genericGetAll() {\r\n        const result = await this.mDataStore.readAll(this.TABLENAME);\r\n        if (result == null) {\r\n            return { success: false, errorMsg: `Could not retrieve all entities from the table ${this.TABLENAME}`, value: null };\r\n        }\r\n        return { success: true, value: result };\r\n    }\r\n    /**\r\n     * @method genericGetById Retrieves the entity corresponding to that Id\r\n     * @param {T} id The id of the entity\r\n     * @protected\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async genericGetById(id) {\r\n        if (!id) {\r\n            throw new Error('No id was passed');\r\n        }\r\n        const result = await this.mDataStore.read(this.TABLENAME, id);\r\n        if (!result) {\r\n            return { success: false, errorMsg: `Notification with the id ${id} was not found`, value: null };\r\n        }\r\n        return { success: true, value: result };\r\n    }\r\n    /**\r\n     * @method genericRemove Deletes an entry in the database based on the entity\r\n     * ID\r\n     * @param {tring|number} id The id of the entry we want to remove\r\n     * @protected\r\n     * @returns {Promise<VoidResult>} A value of whether it was successfully removed or not\r\n     */\r\n    async genericRemove(id) {\r\n        if (!id) {\r\n            throw new Error('No id was passed');\r\n        }\r\n        const result = await this.mDataStore.remove(this.TABLENAME, id);\r\n        if (!result) {\r\n            return { success: result, errorMsg: `The given id ${id} could not be removed from the database` };\r\n        }\r\n        return { success: result };\r\n    }\r\n    /**\r\n     * @method genericRemoveAll Removes all notifications fomr the history store\r\n     * @protected\r\n     * @returns {Promise<VoidResult>} Success message and value return back to calling client\r\n     */\r\n    async genericRemoveAll() {\r\n        const result = await this.mDataStore.removeAll(this.TABLENAME);\r\n        if (!result) {\r\n            return { success: result, errorMsg: 'Could not remove all entries in the database' };\r\n        }\r\n        return { success: result };\r\n    }\r\n    /**\r\n     * @method update Updates a notification in the history store\r\n     * @param {T} entity The updated notification\r\n     * @protected\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async genericUpdate(entity) {\r\n        if (!entity) {\r\n            throw new Error('No updated entity has been passed');\r\n        }\r\n        const read = await this.genericGetById(entity.id);\r\n        if (!read.success) {\r\n            return { success: read.success, errorMsg: `No entry matching the id: ${entity.id}, so there is no entry to be updated`, value: null };\r\n        }\r\n        const result = await this.mDataStore.update(this.TABLENAME, entity);\r\n        if (!result) {\r\n            return { success: result, errorMsg: 'The entity could not be updated', value: null };\r\n        }\r\n        return { success: result, value: entity };\r\n    }\r\n    /**\r\n     * @method genericGetByPage Gets the results depending on the page\r\n     * @param {PageInfo} pageInfo Metadata around the number of items on a page and the page number\r\n     * @protected\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async genericGetByPage(pageInfo) {\r\n        if (!pageInfo) {\r\n            throw new Error('No page info has been passed');\r\n        }\r\n        const result = await this.mDataStore.readByPage(this.TABLENAME, pageInfo);\r\n        if (result == null) {\r\n            return { success: false, errorMsg: 'Could not retrieve the page requested', value: null };\r\n        }\r\n        return { success: true, value: result };\r\n    }\r\n}\r\nexports.Repository = Repository;\r\n//# sourceMappingURL=Repository.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @description Enum used for repository factory to restrict user from passing\r\n * invalid values\r\n */\r\nvar Repositories;\r\n(function (Repositories) {\r\n    Repositories[\"history\"] = \"history\";\r\n    Repositories[\"settings\"] = \"settings\";\r\n})(Repositories = exports.Repositories || (exports.Repositories = {}));\r\n//# sourceMappingURL=RepositoryEnum.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst IndexedDb_1 = require(\"../IndexedDb\");\r\nconst HistoryRepository_1 = require(\"./HistoryRepository\");\r\nconst SettingsRepository_1 = require(\"./SettingsRepository\");\r\n/**\r\n * @class Factory to return repositories.\r\n */\r\nclass RepositoryFactory {\r\n    /**\r\n     * @constructor Constructor Initialises member variables and sets up the\r\n     * database\r\n     * @param datastore The low level database layer\r\n     */\r\n    constructor(datastore) {\r\n        this.mDatastore = datastore;\r\n        const historyRepository = new HistoryRepository_1.HistoryRepository(this.mDatastore);\r\n        const settingsRepository = new SettingsRepository_1.SettingsRepository(this.mDatastore);\r\n        this.mRepositoryStore = { history: historyRepository, settings: settingsRepository };\r\n        const tableNames = [];\r\n        for (const key in this.mRepositoryStore) {\r\n            if (this.mRepositoryStore.hasOwnProperty(key)) {\r\n                const table = { name: this.mRepositoryStore[key]['TABLENAME'], indexName: '', index: '' };\r\n                tableNames.push(table);\r\n            }\r\n        }\r\n        this.mDatastore.initialise(2, tableNames);\r\n    }\r\n    /**\r\n     * @method Returns the singleton instance of itself\r\n     * @returns {RepositoryFactory} Returns an instance of itself\r\n     */\r\n    static get Instance() {\r\n        return this.instance || (this.instance = new this(new IndexedDb_1.IndexedDb(window.indexedDB)));\r\n    }\r\n    /**\r\n     * @method Returns the selected repository\r\n     * @param repositoryName The name of the repository you want to retrieve\r\n     * @returns {Repository} The repository selected\r\n     */\r\n    getRepository(repositoryName) {\r\n        return this.mRepositoryStore[repositoryName];\r\n    }\r\n}\r\nexports.RepositoryFactory = RepositoryFactory;\r\n//# sourceMappingURL=RepositoryFactory.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Repository_1 = require(\"./Repository\");\r\n/**\r\n * @class A class that represents the settings table in the datastore\r\n */\r\nclass SettingsRepository extends Repository_1.Repository {\r\n    /**\r\n     * @constructor Constructor\r\n     * @param {IDatastore} datastore The low leve database layer\r\n     */\r\n    constructor(datastore) {\r\n        super(datastore, 'settings');\r\n    }\r\n    /**\r\n     * @method getTableName return the table name\r\n     * @returns {string} The name of the table\r\n     * @public\r\n     */\r\n    get getTableName() {\r\n        return super.getTableName;\r\n    }\r\n    /**\r\n     * @method create Creates the settings in the database\r\n     * @param {Settings} setting The settings to be saved\r\n     * @public\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async create(setting) {\r\n        const settings = await this.genericGetAll();\r\n        if (!settings.success) {\r\n            return { success: false, errorMsg: settings.errorMsg, value: null };\r\n        }\r\n        if (settings.success && settings.value.length === 1 && this.instanceOf(settings.value[0])) {\r\n            return { success: false, errorMsg: 'There are already settings saved', value: null };\r\n        }\r\n        return await super.genericCreate(setting);\r\n    }\r\n    /**\r\n     * @method getAll Gets the settings in the database\r\n     * @public\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async get() {\r\n        const result = await super.genericGetAll();\r\n        if (result.value.length < 1) {\r\n            return { success: false, errorMsg: 'There were no settings to be found', value: null };\r\n        }\r\n        return { success: true, value: result.value[0] };\r\n    }\r\n    /**\r\n     * @method remove Removes settings fomr the settings store\r\n     * @public\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async remove() {\r\n        return await super.genericRemoveAll();\r\n    }\r\n    /**\r\n     * @method update Updates the settings in the settings store\r\n     * @param updatedSettings The updated settings\r\n     * @public\r\n     * @returns {Promise<ReturnResult>} Success message and value return back to calling client\r\n     */\r\n    async update(updatedSettings) {\r\n        return await super.genericUpdate(updatedSettings);\r\n    }\r\n    /**\r\n     * @method instanceOf This is used as a user defined type guard\r\n     * @param {any} object The object we are checking\r\n     * @returns {}\r\n     */\r\n    instanceOf(object) {\r\n        return object.id !== undefined;\r\n    }\r\n}\r\nexports.SettingsRepository = SettingsRepository;\r\n//# sourceMappingURL=SettingsRepository.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @description Specifies the type of sorting.\r\n */\r\nvar Sorts;\r\n(function (Sorts) {\r\n    Sorts[Sorts[\"ascending\"] = 0] = \"ascending\";\r\n    Sorts[Sorts[\"descending\"] = 1] = \"descending\";\r\n})(Sorts = exports.Sorts || (exports.Sorts = {}));\r\n//# sourceMappingURL=Sort.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst config_1 = require(\"../shared/config\");\r\nconst NotificationTypes_1 = require(\"../shared/Models/NotificationTypes\");\r\nconst RepositoryEnum_1 = require(\"./Persistence/DataLayer/Repositories/RepositoryEnum\");\r\nconst RepositoryFactory_1 = require(\"./Persistence/DataLayer/Repositories/RepositoryFactory\");\r\nconst repositoryFactory = RepositoryFactory_1.RepositoryFactory.Instance;\r\nconst historyRepository = repositoryFactory.getRepository(RepositoryEnum_1.Repositories.history);\r\nconst settingsRepository = repositoryFactory.getRepository(RepositoryEnum_1.Repositories.settings);\r\nlet providerChannel;\r\nlet serviceUUID;\r\nconst centerIdentity = {\r\n    name: 'Notification-Center',\r\n    uuid: '',\r\n    channelId: '',\r\n    channelName: ''\r\n};\r\n/**\r\n * @description Main entry point to the service\r\n */\r\nfin.desktop.main(() => {\r\n    registerService();\r\n    const winConfig = {\r\n        name: 'Notification-Center',\r\n        url: 'ui/index.html',\r\n        autoShow: false,\r\n        defaultHeight: 400,\r\n        defaultWidth: 500,\r\n        resizable: false,\r\n        saveWindowState: false,\r\n        defaultTop: 0,\r\n        frame: false,\r\n        icon: 'ui/favicon.ico',\r\n        'showTaskbarIcon': false\r\n    };\r\n    const notificationCenter = new fin.desktop.Window(winConfig, () => {\r\n        console.log('Notification Center created');\r\n    }, (error) => {\r\n        console.log('Error creating Notification Center:', error);\r\n    });\r\n});\r\n/**\r\n * @method registerService Registers the service and any functions that can be\r\n * consumed\r\n */\r\nasync function registerService() {\r\n    // Register the service\r\n    const serviceId = fin.desktop.Application.getCurrent().uuid;\r\n    providerChannel = await fin.InterApplicationBus.Channel.create(config_1.CHANNEL_NAME);\r\n    centerIdentity.uuid = serviceUUID = serviceId;\r\n    // handle client connections\r\n    providerChannel.onConnection((app, payload) => {\r\n        if (payload && payload.version && payload.version.length > 0) {\r\n            console.log(`connection from client: ${app.name}, version: ${payload.version}`);\r\n        }\r\n        else {\r\n            console.log(`connection from client: ${app.name}, unable to determine version`);\r\n        }\r\n    });\r\n    // Functions called by the client\r\n    providerChannel.register('create-notification', createNotification);\r\n    providerChannel.register('toggle-notification-center', toggleNotificationCenter);\r\n    // Functions called either by the client or the Notification Center\r\n    providerChannel.register('clear-notification', clearNotification);\r\n    providerChannel.register('fetch-app-notifications', fetchAppNotifications);\r\n    providerChannel.register('clear-app-notifications', clearAppNotifications);\r\n    // Functions called by the Notification Center\r\n    providerChannel.register('notification-clicked', notificationClicked);\r\n    providerChannel.register('notification-button-clicked', notificationButtonClicked);\r\n    providerChannel.register('notification-closed', notificationClosed);\r\n    providerChannel.register('fetch-all-notifications', fetchAllNotifications);\r\n    providerChannel.register('clear-all-notifications', clearAllNotifications);\r\n}\r\n// Send notification created to the UI\r\nconst dispatchNotificationCreated = async (payload) => {\r\n    const providerChannelPlugin = await providerChannel;\r\n    const success = await providerChannelPlugin.dispatch(centerIdentity, 'notification-created', payload);\r\n    console.log('success', success);\r\n};\r\n// Send notification cleared to the UI\r\nconst dispatchNotificationCleared = async (payload) => {\r\n    const providerChannelPlugin = await providerChannel;\r\n    const success = await providerChannelPlugin.dispatch(centerIdentity, 'notification-cleared', payload);\r\n    console.log('success', success);\r\n};\r\n// Send app notifications cleared to the UI\r\nconst dispatchAppNotificationsCleared = async (payload) => {\r\n    const providerChannelPlugin = await providerChannel;\r\n    const success = await providerChannelPlugin.dispatch(centerIdentity, 'app-notifications-cleared', payload);\r\n    console.log('success', success);\r\n};\r\n// Send notification clicked to the Client\r\nconst dispatchNotificationClicked = async (payload) => {\r\n    const providerChannelPlugin = await providerChannel;\r\n    const clientIdentity = { name: payload.name, uuid: payload.uuid, channelId: '', channelName: '' };\r\n    const success = await providerChannelPlugin.dispatch(clientIdentity, 'notification-clicked', payload);\r\n    console.log('success', success);\r\n};\r\n// Send notification clicked to the Client\r\nconst dispatchNotificationButtonClicked = async (payload) => {\r\n    const providerChannelPlugin = await providerChannel;\r\n    const clientIdentity = { name: payload.name, uuid: payload.uuid, channelId: '', channelName: '' };\r\n    const success = await providerChannelPlugin.dispatch(clientIdentity, 'notification-button-clicked', payload);\r\n    console.log('success', success);\r\n};\r\n// Send notification closed to the Client\r\nconst dispatchNotificationClosed = async (payload) => {\r\n    const providerChannelPlugin = await providerChannel;\r\n    const clientIdentity = { name: payload.name, uuid: payload.uuid, channelId: '', channelName: '' };\r\n    const success = await providerChannelPlugin.dispatch(clientIdentity, 'notification-closed', payload);\r\n    console.log('success', success);\r\n};\r\nconst dispatchAllNotificationsCleared = async (payload) => {\r\n    const providerChannelPlugin = await providerChannel;\r\n    const success = await providerChannelPlugin.dispatch(centerIdentity, 'all-notifications-cleared', payload);\r\n    console.log('success', success);\r\n};\r\nconst dispatchToggleNotificationCenter = async (payload) => {\r\n    const providerChannelPlugin = await providerChannel;\r\n    const success = await providerChannelPlugin.dispatch(centerIdentity, 'toggle-notification-center', payload);\r\n    console.log('success', success);\r\n};\r\n/**\r\n * Encodes the Id which currently is the uuid:id\r\n * @param payload The notification object\r\n */\r\nfunction encodeID(payload) {\r\n    return `${payload.uuid}:${payload.id}`;\r\n}\r\n/**\r\n * @method decodeID This function retrieves the notification Id\r\n * @param payload The notification object\r\n */\r\nfunction decodeID(payload) {\r\n    return payload.id.slice(payload.uuid.length + 1);\r\n}\r\n/**\r\n * @method createNotification Create the notification and dispatch it to the UI\r\n * @param {object} payload The contents to be dispatched to the UI\r\n * @param {object} sender Window info for the sending client. This can be found in the relevant app.json within the demo folder.\r\n */\r\nasync function createNotification(payload, sender) {\r\n    // For testing/display purposes\r\n    console.log('createNotification hit');\r\n    console.log('payload', payload);\r\n    console.log('sender', sender);\r\n    testDisplay('createNotification', payload, sender);\r\n    const noteType = NotificationTypes_1.TypeResolver(payload);\r\n    const fullPayload = Object.assign({}, payload, sender, { type: noteType });\r\n    const encodedID = encodeID(fullPayload);\r\n    const fullPayloadEncoded = Object.assign({}, fullPayload, { id: encodedID });\r\n    // Manipulate notification data store\r\n    const result = await historyRepository.create(fullPayloadEncoded);\r\n    // Create the notification/toast in the UI\r\n    if (result.success) {\r\n        dispatchNotificationCreated(fullPayload);\r\n    }\r\n    // Return a notification event with the notification context/id to the client\r\n    // that created the notification Or return the payload?\r\n    return result;\r\n}\r\n/**\r\n * @method toggleNotificationCenter Dispatch the notification center toggle action to the UI\r\n * @param {object} sender Window info for the sending client. This can be found in the relevant app.json within the demo folder.\r\n */\r\nasync function toggleNotificationCenter(payload, sender) {\r\n    // For testing/display purposes\r\n    console.log('toggleNotificationCenter hit');\r\n    console.log('payload', payload);\r\n    console.log('sender', sender);\r\n    // Toggle the notification center\r\n    dispatchToggleNotificationCenter(undefined);\r\n    return '';\r\n}\r\n/**\r\n * @method clearNotification Tell the UI to delete a specific notification\r\n * @param {object} payload Should contain the id of the notification we want to delete. Maybe should just be a string\r\n * @param {object} sender Window info for the sending client. This can be found in the relevant app.json within the demo folder.\r\n * @returns {ReturnResult} Whether or not the removal of the notifications was successful.\r\n */\r\nasync function clearNotification(payload, sender) {\r\n    // For testing/display purposes\r\n    console.log('clearNotification hit');\r\n    console.log('payload', payload);\r\n    console.log('sender', sender);\r\n    testDisplay('clearNotification', payload, sender);\r\n    // Grab notificationID from payload. If not present, return error?\r\n    if (!payload.id) {\r\n        return 'ERROR: Must supply a notification ID to clear!';\r\n    }\r\n    const fullPayload = Object.assign({}, payload, sender);\r\n    const encodedID = encodeID(fullPayload);\r\n    // Delete notification from indexeddb\r\n    const result = await historyRepository.remove(encodedID);\r\n    // Delete the notification/toast in UI\r\n    if (result.success) {\r\n        dispatchNotificationCleared(fullPayload);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * @method notificationClicked Tell the Client that a notification was clicked\r\n * @param {object} payload Should contain the id of the notification clicked. Also the uuid and name of the original Client window.\r\n * @param {object} sender UI Window info. Not important.\r\n */\r\nfunction notificationClicked(payload, sender) {\r\n    // For testing/display purposes\r\n    console.log('notificationClicked hit');\r\n    console.log('payload', payload);\r\n    console.log('sender', sender);\r\n    testDisplay('notificationClicked', payload, sender);\r\n    // Send notification clicked event to uuid with the context.\r\n    dispatchNotificationClicked(payload);\r\n    // TODO: What should we return?\r\n    return 'notificationClicked returned';\r\n}\r\nfunction notificationButtonClicked(payload, sender) {\r\n    // For testing/display purposes\r\n    console.log('notificationButtonClicked hit');\r\n    console.log('payload', payload);\r\n    console.log('sender', sender);\r\n    testDisplay('notificationButtonClicked', payload, sender);\r\n    // Send notification clicked event to uuid with the context.\r\n    dispatchNotificationButtonClicked(payload);\r\n    // TODO: What should we return?\r\n    return 'notificationButtonClicked returned';\r\n}\r\n/**\r\n * @method notificationClosed Tell the Client that a notification was closed,\r\n * and delete it from indexeddb\r\n * @param {object} payload Should contain the id of the notification clicked. Also the uuid and name of the original Client window.\r\n * @param {object} sender UI Window info. Not important.\r\n */\r\nasync function notificationClosed(payload, sender) {\r\n    // For testing/display purposes\r\n    console.log('notificationClosed hit');\r\n    console.log('payload', payload);\r\n    console.log('sender', sender);\r\n    testDisplay('notificationClosed', payload, sender);\r\n    const encodedID = encodeID(payload);\r\n    // Delete notification from indexeddb\r\n    const result = await historyRepository.remove(encodedID);\r\n    // Send notification closed event to uuid with the context.\r\n    if (result.success) {\r\n        dispatchNotificationCleared(payload);\r\n        dispatchNotificationClosed(payload);\r\n    }\r\n    // TODO: What should we return?\r\n    return result;\r\n}\r\n/**\r\n * @method fetchAllNotifications Grab all notifications from the Service and\r\n * return it to the UI.\r\n * @param {object} payload Not important\r\n * @param {object} sender Not important.\r\n */\r\nasync function fetchAllNotifications(payload, sender) {\r\n    // For testing/display purposes\r\n    console.log('fetchAllNotifications hit');\r\n    console.log('payload', payload);\r\n    console.log('sender', sender);\r\n    testDisplay('fetchAllNotifications', payload, sender);\r\n    // Grab all notifications from indexeddb.\r\n    const result = await historyRepository.getAll();\r\n    if (result.success) {\r\n        const allNotifications = result.value;\r\n        allNotifications.forEach((notification) => {\r\n            notification.id = decodeID(notification);\r\n        });\r\n        return allNotifications;\r\n    }\r\n    return [];\r\n}\r\n/**\r\n * @method fetchAppNotifications This allows you to fetch apps via your uuid\r\n * @param {undefined} payload The payload can contain the uuid\r\n * @param {ISenderInfo} sender The sender info contains the uuid of the sender\r\n */\r\nasync function fetchAppNotifications(payload, sender) {\r\n    // For testing/display purposes\r\n    console.log('fetchAppNotifications hit');\r\n    console.log('payload', payload);\r\n    console.log('sender', sender);\r\n    testDisplay('fetchAppNotifications', payload, sender);\r\n    // If no uuid supplied in the payload, set to the sender's uuid. This is so\r\n    // you can request another app's notification (such as for the Notification\r\n    // Center)\r\n    if (!payload.uuid) {\r\n        payload.uuid = sender.uuid;\r\n    }\r\n    // Grab an app's notifications from indexeddb\r\n    // Send those notifications to the requesting app.\r\n    const result = await historyRepository.getByUuid(payload.uuid);\r\n    if (result.success) {\r\n        const appNotifications = result.value;\r\n        appNotifications.forEach((notification) => {\r\n            console.log('notification', notification);\r\n            notification.id = decodeID(notification);\r\n        });\r\n        result.value = appNotifications;\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * @method clearAllNotifications Clears all notifications in the database\r\n * @param {undefined} payload Not important\r\n * @param {ISenderInfo} sender Not important\r\n */\r\nasync function clearAllNotifications(payload, sender) {\r\n    console.log('clearAllNotifications hit');\r\n    console.log('payload', payload);\r\n    console.log('sender', sender);\r\n    testDisplay('clearAllNotifications', payload, sender);\r\n    // Delete app notifications from indexeddb\r\n    const result = await historyRepository.removeAll();\r\n    if (result.success) {\r\n        dispatchAllNotificationsCleared(payload);\r\n    }\r\n    // TODO: What should we return?\r\n    return 'clearAllNotifications returned';\r\n}\r\nfunction clearAppNotifications(payload, sender) {\r\n    console.log('clearAppNotifications hit');\r\n    console.log('payload', payload);\r\n    console.log('sender', sender);\r\n    testDisplay('clearAppNotifications', payload, sender);\r\n    // Delete app notifications from indexeddb\r\n    historyRepository.removeByUuid(payload.uuid);\r\n    // Delete the notifications/toasts in UI (TODO: NEED TO REGISTER\r\n    // APP-NOTIFICATIONS-CLEARED IN UI)\r\n    dispatchAppNotificationsCleared(payload);\r\n    // TODO: What should we return?\r\n    return 'clearAppNotifications returned';\r\n}\r\n/**\r\n * @method testDisplay Displays test html on the service\r\n * @param {string} action The action that was hit\r\n * @param {Notification} payload The notification payload\r\n * @param {ISenderInfo} sender The sender info\r\n */\r\nfunction testDisplay(action, payload, sender) {\r\n    document.body.innerHTML = '';\r\n    document.body.innerHTML += `${action} hit <br></br>`;\r\n    document.body.innerHTML += 'PAYLOAD <br></br>';\r\n    const preTagPayload = document.createElement('PRE');\r\n    preTagPayload.textContent = JSON.stringify(payload, null, 4);\r\n    document.body.appendChild(preTagPayload);\r\n    document.body.innerHTML += 'SENDER <br></br>';\r\n    const preTagSender = document.createElement('PRE');\r\n    preTagSender.textContent = JSON.stringify(sender, null, 4);\r\n    document.body.appendChild(preTagSender);\r\n}\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar NotificationTypes;\r\n(function (NotificationTypes) {\r\n    NotificationTypes[\"DEFAULT\"] = \"DEFAULT\";\r\n    NotificationTypes[\"BUTTON\"] = \"BUTTON\";\r\n    NotificationTypes[\"INLINE\"] = \"INLINE\";\r\n    NotificationTypes[\"INLINEBUTTON\"] = \"INLINEBUTTON\";\r\n})(NotificationTypes = exports.NotificationTypes || (exports.NotificationTypes = {}));\r\nfunction TypeResolver(payload) {\r\n    const button = typeof payload.buttons === 'object' && payload.buttons.length > 0 ? true : false;\r\n    const inline = typeof payload.inputs === 'object' && payload.inputs.length > 0 ? true : false;\r\n    let type = NotificationTypes.DEFAULT;\r\n    if (button && !inline) {\r\n        type = NotificationTypes.BUTTON;\r\n    }\r\n    else if (!button && inline) {\r\n        type = NotificationTypes.INLINE;\r\n    }\r\n    else if (button && inline) {\r\n        type = NotificationTypes.INLINEBUTTON;\r\n    }\r\n    return type;\r\n}\r\nexports.TypeResolver = TypeResolver;\r\n//# sourceMappingURL=NotificationTypes.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CHANNEL_NAME = 'of-notifications-service-v1';\r\n//# sourceMappingURL=config.js.map"],"sourceRoot":""}