import 'jest';

import {Application, Identity} from 'hadouken-js-adapter';
import {ElementHandle} from 'puppeteer';

import {NotificationClosedEvent, NotificationClickedEvent, Notification, NotificationOptions} from '../../src/client';

import {fin} from './utils/fin';
import * as notifsRemote from './utils/notificationsRemoteExecution';
import {delay} from './utils/delay';
import {getCardsByNotification, isCenterShowing} from './utils/notificationCenterUtils';

const managerWindowIdentity = {uuid: 'test-app', name: 'test-app'};

describe('When calling createNotification', () => {
    beforeAll(async () => {
        // Show the center to avoid dealing with toasts for the time being
        // TODO: Figure out how to test toasts effectively
        const centerShowing = await isCenterShowing();
        if (!centerShowing) {
            await notifsRemote.toggleNotificationCenter(managerWindowIdentity);
        }
    });

    let testApp: Application;
    let testWindowIdentity: Identity;
    beforeEach(async () => {
        testApp = await createTestApp();
        testWindowIdentity = await testApp.getWindow().then(w => w.identity);
    });

    afterEach(async () => {
        testApp.close();
    });

    // TODO: Make the create call fail properly
    describe('When passing invalid options', () => {
        let createPromise: Promise<Notification>;
        beforeEach(() => {
            // Intentionally circumventing type check with cast for testing purposes
            createPromise = notifsRemote.create(testWindowIdentity, {id: 'invalid-notification'} as NotificationOptions);
        });

        afterEach(async () => {
            // Cleanup the created notification (just in case it does get made)
            await createPromise.catch(() => {});
            await notifsRemote.clear(testWindowIdentity, 'invalid-notification');
        });

        test('An error is thrown', async () => {
            expect(createPromise).rejects.toThrow();
        });

        test('No notification is created', async () => {
            // We want to be sure the action has completed, but don't care about the result
            await createPromise.catch(() => {});

            // Should be no card in the center for this ID
            const noteCards = await getCardsByNotification(testWindowIdentity.uuid, 'invalid-notification');
            expect(noteCards.length).toBe(0);
        });
    });

    describe('With no ID specified', () => {
        const options: NotificationOptions = {
            body: 'Test Notification Body',
            title: 'Test Notification Title'
        };

        let createPromise: Promise<Notification>;
        beforeEach(async () => {
            createPromise = notifsRemote.create(testWindowIdentity, options);
        });

        afterEach(async () => {
            try {
                const note = await createPromise;
                await notifsRemote.clear(testWindowIdentity, note.id);
            } catch (e) {
                // do nothing
            }
        });

        test('An ID is generated by the service and the notification is created and added to the center', async () =>{
            await expect(createPromise).resolves;

            const note = await createPromise;

            expect(note).toMatchObject(options);
            expect(note.id).toMatch(/[0-9]{6,9}/); // Random 9-digit numeric string
        });
    });

    test.skip('legacy test', async () => {
        const clickListener = jest.fn<void, [NotificationClickedEvent]>();
        const closeListener = jest.fn<void, [NotificationClosedEvent]>();
        await notifsRemote.addEventListener(testWindowIdentity, 'notification-clicked', clickListener);
        await notifsRemote.addEventListener(testWindowIdentity, 'notification-closed', closeListener);

        // Check that returned object has the correct data
        const note: Notification = await notifsRemote.create(testWindowIdentity, {body: 'body body body body', title: 'Title title title'});
        expect(note).toHaveProperty('body', 'body body body body');

        // Get all cards for the notification we just created
        const noteCards: ElementHandle[] = await getCardsByNotification(testWindowIdentity.uuid, note.id);

        // Should only be one card per ID
        expect(noteCards.length).toBe(1);

        // Click triggers listener
        await noteCards[0].click();
        await delay(1000);
        expect(clickListener).toHaveBeenCalledTimes(1);

        // Close triggers listener
        const closeButtonHandle: ElementHandle | null = await noteCards[0].$('.notification-close-x');
        if (closeButtonHandle) {
            await closeButtonHandle.click();
        }
        await delay(1000);
        expect(closeListener).toHaveBeenCalledTimes(1);

        // Clear after close returns false
        expect(await notifsRemote.clear(testWindowIdentity, note.id)).toBe(false);
    });
});




// TODO: Window/App creation utils
const nextUuid = (() => {
    let count = 0;
    return () => 'notifications-test-app-' + (count++);
})();

async function createTestApp():Promise<Application> {
    const uuid = nextUuid();
    const app = await fin.Application.create({
        uuid,
        name: uuid,
        url: 'http://localhost:3922/test/test-app.html',
        autoShow: true,
        showTaskbarIcon: false,
        defaultHeight: 400,
        defaultWidth: 500
    });
    await app.run();
    return app;
}
