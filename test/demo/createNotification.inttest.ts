import 'jest';

import {Application, Identity} from 'hadouken-js-adapter';

import {Notification, NotificationOptions} from '../../src/client';
import {SERVICE_IDENTITY} from '../../src/client/internal';

import {fin} from './utils/fin';
import * as notifsRemote from './utils/notificationsRemoteExecution';
import * as notifs from './utils/notificationsNode';
import {getCardsByNotification, isCenterShowing} from './utils/notificationCenterUtils';
import {delay} from './utils/delay';

const managerWindowIdentity = {uuid: 'test-app', name: 'test-app'};

const validOptions: NotificationOptions = {
    body: 'Test Notification Body',
    title: 'Test Notification Title'
};

describe('When calling createNotification', () => {
    describe('With the notification center not showing', () => {
        beforeAll(async () => {
            // Hide the center to be sure we get toasts
            await toggleCenter(false);
        });

        let testApp: Application;
        let testWindowIdentity: Identity;
        beforeEach(async () => {
            testApp = await createTestApp();
            testWindowIdentity = await testApp.getWindow().then(w => w.identity);
        });

        afterEach(async () => {
            testApp.close();
        });

        test('A toast is shown for the notification', async () => {
            const note = await notifsRemote.create(testWindowIdentity, validOptions);
            await delay(1000);

            const toastIdentity = getToastIdentity(testApp.identity, note.id);

            // TODO: Toast utils
            // Check that a toast window does not exist for the notification
            const providerApp = await fin.Application.wrapSync(SERVICE_IDENTITY);
            const childWindows = await providerApp.getChildWindows();
            expect(childWindows.map(win => win.identity)).toContainEqual(toastIdentity);

            await notifsRemote.clear(testWindowIdentity, note.id);
        });
    });

    describe('With the notification center showing', () => {
        beforeAll(async () => {
            // Show the center to ensure we don't get toasts
            await toggleCenter(true);
        });

        let testApp: Application;
        let testWindowIdentity: Identity;
        beforeEach(async () => {
            testApp = await createTestApp();
            testWindowIdentity = await testApp.getWindow().then(w => w.identity);
        });

        afterEach(async () => {
            testApp.close();
        });

        test('No toast is shown for the created notification', async () => {
            const note = await notifsRemote.create(testWindowIdentity, validOptions);
            await delay(1000);

            const toastIdentity = getToastIdentity(testApp.identity, note.id);

            // Check that a toast window does not exist for the notification
            const providerApp = await fin.Application.wrapSync(SERVICE_IDENTITY);
            const childWindows = await providerApp.getChildWindows();
            expect(childWindows).not.toContainEqual(fin.Window.wrapSync(toastIdentity));

            await notifsRemote.clear(testWindowIdentity, note.id);
        });

        describe('When passing invalid options', () => {
            let createPromise: Promise<Notification>;
            beforeEach(() => {
                // Intentionally circumventing type check with cast for testing purposes
                createPromise = notifsRemote.create(testWindowIdentity, {id: 'invalid-notification'} as NotificationOptions);
            });

            afterEach(async () => {
                // Cleanup the created notification (just in case it does get made)
                await createPromise.catch(() => {});
                await notifsRemote.clear(testWindowIdentity, 'invalid-notification');
            });

            test('An error is thrown', async () => {
                expect(createPromise).rejects.toThrow();
            });

            test('No notification is created', async () => {
                // We want to be sure the action has completed, but don't care about the result
                await createPromise.catch(() => {});

                // Should be no card in the center for this ID
                const noteCards = await getCardsByNotification(testWindowIdentity.uuid, 'invalid-notification');
                expect(noteCards.length).toBe(0);
            });
        });

        describe('With no ID specified', () => {
            let createPromise: Promise<Notification>;
            beforeEach(async () => {
                createPromise = notifsRemote.create(testWindowIdentity, validOptions);
            });

            afterEach(async () => {
                try {
                    const note = await createPromise;
                    await notifsRemote.clear(testWindowIdentity, note.id);
                } catch (e) {
                    // do nothing
                }
            });

            test('An ID is generated by the service and the notification is created and added to the center', async () =>{
                await expect(createPromise).resolves;

                const note = await createPromise;

                expect(note).toMatchObject(validOptions);
                expect(note.id).toMatch(/[0-9]{6,9}/); // Random 9-digit numeric string
            });
        });
    });
});

// TODO: this should probably be a util
async function toggleCenter(show?: boolean) {
    const centerShowing = await isCenterShowing();
    if (show === true && !centerShowing) {
        await notifs.toggleNotificationCenter();
    } else if (show === false && centerShowing) {
        await notifs.toggleNotificationCenter();
    } else {
        await notifs.toggleNotificationCenter();
    }
    // Slight delay to let the animation finish
    await delay(200);
}

// TODO: make part of some kind of toast utils
function getToastIdentity(sourceApp: Identity, notificationId: string): Identity {
    return {uuid: SERVICE_IDENTITY.uuid, name: `Notification-Toast:${sourceApp.uuid}:${notificationId}`};
}

// TODO: Window/App creation utils
const nextUuid = (() => {
    let count = 0;
    return () => 'notifications-test-app-' + (count++);
})();

async function createTestApp():Promise<Application> {
    const uuid = nextUuid();
    const app = await fin.Application.create({
        uuid,
        name: uuid,
        url: 'http://localhost:3922/test/test-app.html',
        autoShow: true,
        showTaskbarIcon: false,
        defaultHeight: 400,
        defaultWidth: 500
    });
    await app.run();
    return app;
}
