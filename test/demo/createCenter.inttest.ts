// Tests for creating notifications with the center showing (i.e. no toasts)

import 'jest';

import {Application, Window} from 'hadouken-js-adapter';

import {createApp} from './utils/spawnRemote';
import {isCenterShowing, getCardsByNotification} from './utils/notificationCenterUtils';
import * as notifsRemote from './utils/notificationsRemoteExecution';
import { Notification, NotificationOptions } from '../../src/client';

const testManagerIdentity = {uuid: 'test-app', name: 'test-app'};

type DisplayType = 'toast'|'center';

interface UtilFunction {

}

const functionMap: {[key in DisplayType]: UtilFunction} = {
    toast: {

    },
    center: {

    }
};

describe.each(['center'] as DisplayType[])('When creating a notification - %s', (displayType: DisplayType) => {
    let testApp: Application;
    let testWindow: Window;

    beforeAll(async () => {
        // Toggle the center on/off based on test type
        if (displayType === 'center' && !(await isCenterShowing())) {
            await notifsRemote.toggleNotificationCenter(testManagerIdentity);
        } else if (displayType === 'toast' && await isCenterShowing()) {
            await notifsRemote.toggleNotificationCenter(testManagerIdentity);
        }
    });

    beforeEach(async () => {
        testApp = await createApp(testManagerIdentity, {});
        testWindow = await testApp.getWindow();
    });

    afterEach(async () => {
        await notifsRemote.clearAll(testWindow.identity);
        await testApp.quit();
    });

    describe('When options does not include title and/or body', () => {
        const options: NotificationOptions = {id: 'invalid-notification'} as NotificationOptions;

        let createPromise: Promise<Notification>;
        beforeEach(async () => {
            // Intentionally circumventing type check with cast for testing purposes
            createPromise = notifsRemote.create(testWindow.identity, options);
            
            // We want to be sure the operation is completed, but don't care about the result
            await createPromise.catch(() => {});
        });

        afterEach(async () => {
            // Cleanup the created notification (just in case it does get made)
            await notifsRemote.clear(testWindow.identity, options.id!);
        });

        test('The promise rejects with a suitable error message', async () => {
            await expect(createPromise).rejects.toThrow(/Invalid arguments passed to createNotification/);
        });

        test('A card is not added to the notification center', async () => {
            const noteCards = await getCardsByNotification(testApp.identity.uuid, options.id!);
            expect(noteCards).toEqual([]);
        });
        test('The notification does not appear in the result of getAll', async () => {
            const appNotes = await notifsRemote.getAll(testWindow.identity);
            expect(appNotes).toEqual([]);
        });
    });

    describe('When options does not include id', () => {
        const options: NotificationOptions = {body: 'Test Notification Body', title: 'Test Notificaiton Title'};

        test.todo('An id is generated by the service and returned in the hydrated object');
        test.todo('The notification is created as expected');
    });

    describe('When passing a valid set of options', () => {
        const options: NotificationOptions = {body: 'Test Notification Body', title: 'Test Notificaiton Title'};

        test.todo('The promise resolves to the fully hydrated notification object');
        test.todo('The missing options are filled in with default values');
        test.todo('A card appears in the notification center');
        test.todo('The card has the same data as the returned notification object');
        test.todo('The notification is included in the result of a getAll call');
    });
});
